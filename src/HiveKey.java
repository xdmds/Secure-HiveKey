import java.util.ArrayList;
import java.util.Arrays;
import java.security.SecureRandom;
import java.util.concurrent.TimeUnit;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class HiveKey {
    private long actual_seed; //SecureRandom.generateSeed(64 bits)
    private byte[] key; //SecureRandom.next(128 bits);
    private ArrayList<byte[]> parent_seeds;
    private HKTimestamp timestamp;
    private byte[] left_seed;
    private long left_seed_prime;
    private long right_seed_prime;
    private byte[] right_seed;
    private byte[] child_seed;
    private final static char[] hexArray = "0123456789ABCDEF".toCharArray();

    public HiveKey() {
        long ts = System.currentTimeMillis();
        this.timestamp = new HKTimestamp(ts);
        this.parent_seeds = new ArrayList<byte[]>(6);
        this.left_seed = new byte[8];
        this.right_seed = new byte[8];
        this.key = new byte[8];
    }

    /**
     * Generates a random seed used to randomize the 6 parent seeds for HiveKey
     */
    private void generateParents() {
        //generate a random seed
        SecureRandom random = new SecureRandom();
        byte[] init_seed = random.generateSeed(8);
        random.setSeed(init_seed);

        //generate 6 parent seeds
        for (int i = 0; i < 6; i++) {
            byte[] next_seed = new byte[8];
            random.nextBytes(next_seed);

            //add to parent_seed array
            this.parent_seeds.add(next_seed);
        }
    }

    /**
     * Randomly choose a parent seed and set the left/right neighbor seeds
     *
     * @return the chosen parent seed
     */
    private byte[] disturb() {
        //get parent seed from timestamp
        String p_id = this.timestamp.getParentIDBits();
        int p_index = (Integer.parseInt(p_id, 2) % 6);
        byte[] p = this.parent_seeds.get(p_index);

        //get/set left and right neighbor seedsp
        int left_index = (p_index + 5) % 6;
        this.left_seed = this.parent_seeds.get(left_index);
        this.right_seed = this.parent_seeds.get((p_index + 1) % 6);

        return p;
    }

    /**
     * Generate the child seed
     */
    private void generateChild(byte[] p) {
        //generate a random number using parent_seed as seed
        SecureRandom random = new SecureRandom();
        random.setSeed(p);

        //get child id from timestamp and num children
        String c_id = this.timestamp.getChildIDBits();
        int num_children = 6;
        if (this.timestamp.getVer() == 1) {
            num_children = 18;
        }

        //calculate index
        int c_index = (Integer.parseInt(c_id, 2) % num_children);
        ArrayList<byte[]> child_seeds = new ArrayList<byte[]>(num_children);
        for (int i = 0; i < num_children; i++) {
            byte[] next_seed = new byte[8];
            random.nextBytes(next_seed);

            //add to child_seeds array
            child_seeds.add(next_seed);
        }

        this.child_seed = child_seeds.get(c_index);
    }

    /**
     * Generates the seed used for the actual key generation, done by disturbing the hive and integrating
     * the left and right neighbors
     */
    private void computeActualSeed() {
        //60% MSB of left_seed (eq. 4a)
        this.left_seed_prime = ByteUtils.bytesToLong(this.left_seed) & 0xfffffffffc000000L; //most significant 38 bits are 1. 60% is 38.4

        //40% LSB of right_seed (eq. 4b)
        this.right_seed_prime = ByteUtils.bytesToLong(this.right_seed) & 0x1ffffffL; //least significant 25 bits are 1. 40% is 25.6

        //compute/store actual_seed (eq. 5)
        this.actual_seed = ByteUtils.bytesToLong(this.child_seed)
                ^ (this.left_seed_prime | this.right_seed_prime)
                ^ this.timestamp.getTimestamp(); //isn't the timestamp 32 bits?
    }

    /**
     * Generates the encryption key from the actual seed
     */
    private void generateKey() {
        SecureRandom random = new SecureRandom();
        random.setSeed(this.actual_seed);

        //retrieve 4 lsbs from timestamp and used as state s
        int state = Integer.parseInt(this.timestamp.getTimestampBits().substring(this.timestamp.getTimestampBits().length() - 4), 2);

        //get the sth sequence generated by the PRNG to be used as the key
        byte[] temp_key = new byte[16];
        for (int i = 0; i < state; i++) {
            random.nextBytes(temp_key);
        }
        this.key = temp_key;
    }

    private String bytesToHex(byte[] in) {
        final StringBuilder builder = new StringBuilder();
        for (byte b : in) {
            builder.append(String.format("%02x", b));
        }
        return builder.toString();
    }

    public String run() {
        this.generateParents();
        byte[] p = this.disturb();
        this.generateChild(p);
        this.computeActualSeed();
        this.generateKey();
        String key_string = this.bytesToHex(this.key);

        return key_string;

    }

    /**
     * Creates a encryption key sequences with random delays. These keys are then evaluated
     * with ISS and STS and compared to the results of HiveSec's implementation using Random()
     *
     * @param args command line arguments, if any
     */
    public static void main(String[] args) throws IOException {
        if( args.length != 2) {
            System.out.println("Usage: java HiveKey <number of key sequences> <output filename>");
            System.exit(0);
        }

        //generate 10240 key sequence - output to file
        BufferedWriter writer = new BufferedWriter(new FileWriter(args[1]));
        HiveKey hk = new HiveKey();
        for (int i = 0; i < Integer.parseInt(args[0]); i++) {
            SecureRandom random = new SecureRandom();
            int delay = random.nextInt(3);
            String key_string = hk.run();
            writer.write(key_string + "\n");
            
            //delay - random from 0-2 seconds, between each key sequence generated

            try {
                TimeUnit.SECONDS.sleep(delay);
            } catch (InterruptedException e) {
                System.out.println("error: " + e);
            }
        }

        writer.close();
        //sequence evaluation
    }
}